    public void run() {
        while (!Thread.currentThread().isInterrupted()) {
            try {
                // X·ª≠ l√Ω task n·∫∑ng ·ªü background, t√°ch bi·ªát ho√†n to√†n v·ªõi request c·ªßa user
                boolean taskProcessed = processNextJob(); 
                
                // N·∫øu kh√¥ng c√≥ task th√¨ ng·ªß (sleep) ƒë·ªÉ ti·∫øt ki·ªám t√†i nguy√™n CPU
                if (!taskProcessed) Thread.sleep(currentSleepMs);
            } catch (Exception e) { e.printStackTrace(); }
        }
    }



    @Override
    public void run() {
        System.out.println("ü§ñ " + workerId + " (CLOUD) ƒê√É KH·ªûI ƒê·ªòNG...");

        while (!Thread.currentThread().isInterrupted()) {
            try {
                boolean taskProcessed = processNextJob();

                // Exponential backoff: Increase sleep when idle, reset when busy
                if (taskProcessed) {
                    currentSleepMs = MIN_SLEEP_MS; // Reset to 2s when task found
                } else {
                    // Gradually increase to max 10s when no tasks
                    currentSleepMs = Math.min(currentSleepMs + 1000, MAX_SLEEP_MS);
                }

                Thread.sleep(currentSleepMs);
            } catch (InterruptedException e) {
                System.out.println("‚ö†Ô∏è " + workerId + ": Nh·∫≠n t√≠n hi·ªáu shutdown...");
                Thread.currentThread().interrupt(); // Restore interrupted status
                break; // Exit loop gracefully
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        System.out.println("üõë " + workerId + ": ƒê√£ d·ª´ng ho·∫°t ƒë·ªông.");
    }

T·∫°i sao n√≥ Nhanh & ƒê·ªô tr·ªÖ th·∫•p? (G√≥c ƒë·ªô k·ªπ thu·∫≠t)
Header t·ªëi gi·∫£n: UDP header ch·ªâ c√≥ k√≠ch th∆∞·ªõc 8 bytes (so v·ªõi t·ªëi thi·ªÉu 20 bytes c·ªßa TCP). ƒêi·ªÅu n√†y gi·∫£m t·∫£i (overhead) cho bƒÉng th√¥ng m·∫°ng.

Kh√¥ng b·∫Øt tay (Connectionless): B·ªè qua qu√° tr√¨nh "b·∫Øt tay 3 b∆∞·ªõc" (3-way handshake). G·ª≠i d·ªØ li·ªáu ngay l·∫≠p t·ª©c m√† kh√¥ng c·∫ßn thi·∫øt l·∫≠p ƒë∆∞·ªùng truy·ªÅn tr∆∞·ªõc.

Fire-and-Forget: G·ª≠i xong l√† xong, kh√¥ng ch·ªù ph·∫£n h·ªìi (ACK).

2. Chi ti·∫øt v·ªÅ Nh∆∞·ª£c ƒëi·ªÉm (G√≥c ƒë·ªô x·ª≠ l√Ω Code)
Khi l·∫≠p tr√¨nh v·ªõi UDP, b·∫°n c·∫ßn ch·∫•p nh·∫≠n c√°c r·ªßi ro sau ƒë·ªÉ ƒë·ªïi l·∫•y t·ªëc ƒë·ªô:

M·∫•t g√≥i tin (Packet Loss): Kh√¥ng c√≥ c∆° ch·∫ø g·ª≠i l·∫°i (retransmission) n·∫øu g√≥i tin b·ªã r∆°i r·ªõt tr√™n ƒë∆∞·ªùng ƒëi.

Sai th·ª© t·ª± (Out of Order): G·ª≠i theo th·ª© t·ª± A -> B -> C, nh∆∞ng c√≥ th·ªÉ ƒë·∫øn n∆°i l√† C -> A -> B. ·ª®ng d·ª•ng ph·∫£i t·ª± x·ª≠ l√Ω vi·ªác s·∫Øp x·∫øp n·∫øu c·∫ßn.

Kh√¥ng ki·ªÉm so√°t t·∫Øc ngh·∫Ωn: UDP s·∫Ω ti·∫øp t·ª•c "b∆°m" d·ªØ li·ªáu ra m·∫°ng k·ªÉ c·∫£ khi m·∫°ng ƒëang b·ªã t·∫Øc, d·ªÖ d·∫´n ƒë·∫øn packet drop h√†ng lo·∫°t.

3. Khi n√†o d√πng UDP?
Real-time applications: Video Streaming, VoIP (g·ªçi tho·∫°i), Game Online (FPS, MOBA) - n∆°i m√† t·ªëc ƒë·ªô quan tr·ªçng h∆°n s·ª± ho√†n h·∫£o (m·∫•t m·ªôt v√†i frame h√¨nh kh√¥ng sao, nh∆∞ng lag l√† h·ªèng tr·∫£i nghi·ªám).

D·ªãch v·ª• truy v·∫•n nhanh: DNS, DHCP.